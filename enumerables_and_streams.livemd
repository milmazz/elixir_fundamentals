# Numerables y Flujos (Enumerables, Streams)

## Numerables

Elixir provee el concepto de numerables y el módulo [`Enum`](https://hexdocs.pm/elixir/Enum.html) para trabajar con ellos. Ya hemos visto dos tipos de numerables, listas y mapas.

```elixir
Enum.map([1, 2, 3], fn x -> x * 2 end)
```

```elixir
Enum.map(%{1 => 2, 3 => 4}, fn {k, v} -> k * v end)
```

El módulo `Enum` provee un gran rango de funciones para transformar, ordenar, agrupar, filtrar y obtener ítems desde numerables. Es uno de los módulos frecuentemente usado por los desarrolladores en Elixir.

Elixir también provee rangos:

```elixir
Enum.map(1..3, fn x -> x * 2 end)
```

```elixir
Enum.reduce(1..3, 0, &+/2)
```

Las funciones en el módulo `Enum` están limitadas a, como su nombre lo indica, enumerar valores en estructuras de datos. Para operaciones específicas, como insertar o actualizar algún elemento en particular, necesitas utilizar módulos específicos para dicho tipo de dato. Por ejemplo, si quieres insertar un elemento en una cierta posición en una lista, debes usar la función `List.insert_at/3` disponible en el módulo [`List`](https://hexdocs.pm/elixir/List.html), dado que no tendría mucho sentido insertar dicho valor en un rango, por ejemplo.

Decimos que las funciones en el módulo `Enum` son polimorfas porque ellas pueden trabajar con distintos tipos de datos. En particular, las funciones en este módulo pueden trabajar con cualquier tipo de dato que implemente el protocolo [`Enumerable`](https://hexdocs.pm/elixir/Enumerable.html). Discutiremos sobre Protocolos en clases posteriores; pero por ahora vamos a avanzar con un tipo específico de numerable llamado stream o flujo.

## Evaluación temprana vs. Evaluación perezosa

Todas las funciones del módulo `Enum` son ansiosas o ejecutan una evaluación temprana. Muchas funciones esperan un numerable y retornan una lista:

```elixir
odd? = &(rem(&1, 2) != 0)
Enum.filter(1..3, odd?)
```

Esto significa que cuando estamos realizando múltiples operaciones con `Enum`, cada operación va a generar una lista intermedia hasta que finalmente alcancemos el resultado:

```elixir
1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum()
```

El ejemplo anterior tiene una secuencia de operaciones. Comenzamos con un rango y luego multiplicamos cada elemento en dicho rango por tres. La primera operación creará y retornará una lista con `100_000` elementos. Luego filtramos la lista previa y mantenemos solo los números impares, generando una nueva lista, ahora con `50_000` elementos, y finalmente sumamos todos los elementos.

## El operador pipe (|>)

El símbolo `|>` usado en el ejemplo previo es conocido como el operador _pipe_, dicho operador toma la salida de la expresión a su izquierda y la pasa como primer argumento a la función que es llamada a su lado derecho. Es similar al operador `|` en Unix. Su propósito es resaltar que los datos están siendo transformados por una serie de funciones. Para ver cómo el operador `|>` contribuye a generar código más limpio, vamos a reescribir el ejemplo anterior sin usar dicho operador.

```elixir
Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))
```

Puedes encontrar más información acerca del operador _pipe_ leyendo [su documentación](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2).

## Flujos o Streams

Como alternativa a `Enum`, Elixir provee el módulo [`Stream`](https://hexdocs.pm/elixir/Stream.html), el cual soporta evaluación perezosa.

```elixir
1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum()
```

Como ya mencionaba, los _Streams_ son perezosos, y también una manera de componer numerables.

En el ejemplo anterior, `1..100_000 |> Stream.map(&(&1 * 3))` retorna un tipo de dato, un flujo, que representa el cálculo triplica el valor de cada elemento del rango `1..100_000`

```elixir
1..100_000 |> Stream.map(&(&1 * 3))
```

Además, podemos decir que son componibles porque podemos juntar secuencias de operaciones sobre flujos o streams.

```elixir
1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?)
```

En lugar de generar listas intermedias, los flujos construyen una serie de cálculos que en realidad se invocan solo cuando pasamos el flujo al módulo `Enum`. Los flujos son útiles cuando trabajamos con largas, posiblemente infinita, colecciones de datos.

Muchas funciones en el módulo `Stream` aceptan cualquier numerable como argumento y retornan un flujo como resultado. También provee funciones para crear flujos. Por ejemplo, `Stream.cycle/1` puede ser usada para crear un flujo que genera un ciclo infinito del numerable dado. Ten cuidado y evita llamar funciones como `Enum.map/2` sobre dicho flujo, de lo contrario generarás un ciclo infinito.

```elixir
stream = Stream.cycle([1, 2, 3])
Enum.take(stream, 10)
```

Por otro lado, `Stream.unfold/2` puede usarse para generar valores a partir de un valor inicial dado:

```elixir
stream = Stream.unfold("hełło", &String.next_codepoint/1)
Enum.take(stream, 3)
```

Otra función interesante es `Stream.resource/3`, la cual puedes usar para envolver recursos, garantizando que dichos recursos se abran justo antes de numeración y se cierren al final, incluso en caso de fallas. Por ejemlo, `File.stream!/1` se basa en `Stream.resource/3` para manejar ficheros como flujos.

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
stream = File.stream!("path/to/file")
Enum.take(stream, 10)
```

<!-- livebook:{"break_markdown":true} -->

El ejemplo anterior obtendrá las primeras 10 líneas del fichero que seleccionaste. Esto significa que las secuencias pueden ser muy útiles para manejar archivos grandes o incluso recursos lentos como los recursos de red.

La cantidad de funcionalidades en los módulos [`Enum`](https://hexdocs.pm/elixir/Enum.html) y [`Stream`](https://hexdocs.pm/elixir/Stream.html) puede ser abrumador al principio, pero con la práctica te irás familiarizando con ellos. En particular, te recomiendo concentrarte primero en el módulo `Enum` y solo después puedes avanzar a `Stream` en aquellos casos donde veas conveniente la evaluación perezosa, ya sea para manejar recursos lentos o colecciones grandes, posiblemente infinitas.

En la próxima clase, veremos una característica central de Elixir, los Procesos, los cuales nos permite escribir programas concurrentes, paralelos y distribuidos de una manera fácil y comprensible.
